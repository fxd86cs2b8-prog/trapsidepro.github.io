<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Qwen Air Pro — Method 4 (Safe)</title>

  <script type="importmap">
    { "imports": { "@mlc-ai/web-llm": "https://esm.run/@mlc-ai/web-llm" } }
  </script>

  <style>
    /* UI: clean, mobile-friendly, lightweight */
    :root{
      --bg1:#e6efff; --bg2:#f4f7fb; --primary:#007AFF; --accent:#5856D6; --muted:#8e8e93; --card:rgba(255,255,255,0.92);
    }
    html,body{height:100%;margin:0;font-family:-apple-system,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(160deg,var(--bg1),var(--bg2));-webkit-font-smoothing:antialiased}
    .card{width:94%;max-width:470px;margin:4vh auto;height:92vh;background:var(--card);border-radius:18px;display:flex;flex-direction:column;overflow:hidden;padding-top:env(safe-area-inset-top);box-shadow:0 8px 30px rgba(21,28,40,0.08)}
    header{display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid rgba(0,0,0,0.04);background:linear-gradient(180deg, rgba(255,255,255,0.95), transparent)}
    .title{font-weight:700;color:#0b1220}
    .controls{display:flex;gap:8px;align-items:center}
    .btn{background:transparent;border:1px solid rgba(0,0,0,0.06);padding:6px 10px;border-radius:12px;font-size:13px;cursor:pointer;box-shadow:0 1px 0 rgba(255,255,255,0.6)}
    .btn--danger{color:#ff3b30;border-color:rgba(255,59,48,0.12)}
    .toggle{display:inline-flex;align-items:center;gap:8px;font-size:13px;cursor:pointer}
    .toggle input{width:40px;height:22px;appearance:none;background:#e9e9ef;border-radius:11px;position:relative;outline:none;cursor:pointer}
    .toggle input:after{content:"";position:absolute;left:3px;top:3px;width:16px;height:16px;border-radius:8px;background:#fff;box-shadow:0 1px 2px rgba(0,0,0,0.06);transition:transform 160ms ease}
    .toggle input:checked{background:linear-gradient(90deg,var(--primary),var(--accent))}
    .toggle input:checked:after{transform:translateX(18px)}
    main#chat{flex:1;overflow:auto;padding:14px;display:flex;flex-direction:column;gap:12px;background:transparent}
    .msg{max-width:78%;padding:10px 14px;border-radius:16px;word-break:break-word;font-size:15px;line-height:1.35;box-shadow:0 6px 14px rgba(11,17,24,0.04)}
    .user{align-self:flex-end;background:linear-gradient(180deg,var(--primary),#005bd8);color:#fff;border-bottom-right-radius:6px}
    .assistant{align-self:flex-start;background:#fff;color:#0b1220;border-bottom-left-radius:6px}
    .muted{font-size:12px;color:var(--muted)}
    .input-row{display:flex;padding:10px;gap:8px;border-top:1px solid rgba(0,0,0,0.04);background:linear-gradient(180deg, rgba(255,255,255,0.95), transparent)}
    input[type="text"]{flex:1;padding:12px;border-radius:18px;border:1px solid #e9e9ef;font-size:15px;background:#fff}
    button#send{background:linear-gradient(90deg,var(--primary),var(--accent));color:#fff;border:none;padding:10px 14px;border-radius:14px;cursor:pointer;box-shadow:0 6px 18px rgba(0,122,255,0.12)}
    button:disabled{opacity:0.5;cursor:not-allowed}

    /* overlay + modal (first-time only) */
    .overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(8,12,20,0.12);z-index:60;padding:20px}
    .progressModal{width:88%;max-width:420px;background:var(--card);border-radius:12px;padding:14px;text-align:center;box-shadow:0 12px 40px rgba(6,10,18,0.12)}
    .progressBar{height:8px;background:#eee;border-radius:8px;overflow:hidden;margin-top:12px}
    .progressBar > i{display:block;height:100%;width:0;background:linear-gradient(90deg,var(--primary),var(--accent));transition:width 120ms linear}

    /* traits modal */
    .traitsModal{width:92%;max-width:420px;background:var(--card);border-radius:12px;padding:12px;box-shadow:0 12px 40px rgba(6,10,18,0.12)}
    .trait-chips{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px}
    .chip{background:#f3f6ff;border:1px solid rgba(0,0,0,0.03);padding:6px 10px;border-radius:999px;font-size:13px}
    .traitsEditor{display:flex;flex-direction:column;gap:8px;margin-top:10px}
    .traitsEditor input{padding:8px;border-radius:8px;border:1px solid #eee}
    .modalActions{display:flex;gap:8px;justify-content:flex-end;margin-top:10px}

    /* reasoning block */
    .reasoning {background:linear-gradient(180deg,#fbfdff,#f5f8ff);border:1px solid rgba(0,0,0,0.03);padding:8px;border-radius:12px;margin-top:6px;font-size:13px;color:#0b1220}
    .reasoning .step {margin:4px 0;padding-left:6px}
    .reason-toggle{display:inline-flex;gap:8px;align-items:center;font-size:13px;cursor:pointer}

    @media (max-width:360px){
      .card{width:98%;height:94vh}
      .msg{font-size:14px}
    }
  </style>
</head>
<body>
  <div class="card" id="card">
    <!-- overlay used for first-time download ONLY -->
    <div class="overlay" id="overlay" aria-hidden="true">
      <div class="progressModal" id="progressModal" role="status" aria-live="polite">
        <div style="font-weight:600" id="overlayTitle">Preparing model…</div>
        <div class="muted" id="overlaySub">Optimized for low-memory devices</div>
        <div class="progressBar" aria-hidden="true"><i id="overlayBar"></i></div>
      </div>
    </div>

    <header>
      <div class="title">Qwen Air Pro</div>
      <div class="controls">
        <label class="toggle" title="Low Power Mode">
          <input id="lowPowerToggle" type="checkbox" />
        </label>

        <!-- Chain-of-Thought toggle -->
        <label class="toggle" title="Enable brief step-by-step reasoning">
          <input id="cotToggle" type="checkbox" />
        </label>

        <!-- Always show reasoning inline toggle -->
        <label class="toggle" title="Show reasoning inline">
          <input id="showReasoningToggle" type="checkbox" />
        </label>

        <button class="btn" id="traitsBtn">Traits</button>
        <button class="btn btn--danger" id="resetBtn">Reset</button>
      </div>
    </header>

    <main id="chat" aria-live="polite" aria-atomic="false">
      <div class="msg assistant">Ready. Stateless worker strategy active.</div>
    </main>

    <div class="input-row">
      <input id="userInput" type="text" placeholder="Ask me anything..." autocomplete="off" />
      <button id="send">Send</button>
    </div>
  </div>

  <!-- Traits Editor Overlay -->
  <div class="overlay" id="traitsOverlay" aria-hidden="true">
    <div class="traitsModal" role="dialog" aria-modal="true" aria-labelledby="traitsTitle">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div id="traitsTitle" style="font-weight:700">User Traits (max 7)</div>
        <div class="muted" id="traitsCount">0/7</div>
      </div>

      <div class="trait-chips" id="traitsChips" aria-hidden="false"></div>

      <div class="traitsEditor" id="traitsEditor"></div>

      <div class="modalActions">
        <button class="btn" id="addTraitBtn">+ Add</button>
        <button class="btn" id="saveTraitsBtn">Save</button>
        <button class="btn" id="cancelTraitsBtn">Cancel</button>
      </div>

      <div class="muted" style="margin-top:8px">Low Power mode injects fewer traits and limits history to reduce memory use.</div>
    </div>
  </div>

  <script type="module">
    import * as webllm from "@mlc-ai/web-llm";

    // Config and caps
    const MODEL_ID = "Qwen2.5-0.5B-Instruct-q4f16_1-MLC";
    const MAX_TRAITS = 7;
    const LOWPOWER_TRAITS = 3;
    const HISTORY_TURNS_NORMAL = 1;      // user+assistant
    const HISTORY_TURNS_LOW = 0;
    const REPLY_CHAR_CAP_NORMAL = 2400;  // ~600 tokens estimate
    const REPLY_CHAR_CAP_LOW = 900;      // strict low-power
    const SYSTEM_PROMPT_CHAR_CAP = 420;  // cap system prompt
    const TRAITS_KEY = 'qwen_user_traits_v1';
    const LOWPOWER_KEY = 'qwen_lowpower_v1';
    const COT_KEY = 'qwen_cot_v1';
    const SHOW_REASONING_KEY = 'qwen_show_reasoning_v1';
    const MODEL_DOWNLOADED_KEY = 'qwen_model_downloaded_v1';

    // UI refs
    const chat = document.getElementById('chat');
    const userInput = document.getElementById('userInput');
    const sendBtn = document.getElementById('send');
    const resetBtn = document.getElementById('resetBtn');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlaySub = document.getElementById('overlaySub');
    const overlayBar = document.getElementById('overlayBar');
    const lowPowerToggle = document.getElementById('lowPowerToggle');
    const cotToggle = document.getElementById('cotToggle');
    const showReasoningToggle = document.getElementById('showReasoningToggle');
    const traitsBtn = document.getElementById('traitsBtn');

    // modal refs
    const traitsOverlay = document.getElementById('traitsOverlay');
    const traitsEditor = document.getElementById('traitsEditor');
    const traitsChips = document.getElementById('traitsChips');
    const addTraitBtn = document.getElementById('addTraitBtn');
    const saveTraitsBtn = document.getElementById('saveTraitsBtn');
    const cancelTraitsBtn = document.getElementById('cancelTraitsBtn');
    const traitsCount = document.getElementById('traitsCount');

    // state
    let userTraits = [];
    let lowPower = false;
    let cotEnabled = false;
    let showReasoningInline = false;
    let history = [];
    let engine = null;
    const requestQueue = [];
    let processing = false;

    // persistence helpers
    function loadTraits(){ try { const r = localStorage.getItem(TRAITS_KEY); return r ? JSON.parse(r).slice(0,MAX_TRAITS) : []; } catch { return []; } }
    function saveTraits(arr){ try { localStorage.setItem(TRAITS_KEY, JSON.stringify((arr||[]).slice(0,MAX_TRAITS))); } catch {} }
    function loadLowPower(){ try { return localStorage.getItem(LOWPOWER_KEY) === '1'; } catch { return false; } }
    function saveLowPower(v){ try { localStorage.setItem(LOWPOWER_KEY, v ? '1' : '0'); } catch {} }
    function loadCoT(){ try { return localStorage.getItem(COT_KEY) === '1'; } catch { return false; } }
    function saveCoT(v){ try { localStorage.setItem(COT_KEY, v ? '1' : '0'); } catch {} }
    function loadShowReasoning(){ try { return localStorage.getItem(SHOW_REASONING_KEY) === '1'; } catch { return false; } }
    function saveShowReasoning(v){ try { localStorage.setItem(SHOW_REASONING_KEY, v ? '1' : '0'); } catch {} }
    function modelDownloadedFlag(){ try { return localStorage.getItem(MODEL_DOWNLOADED_KEY) === '1'; } catch { return false; } }
    function setModelDownloadedFlag(){ try { localStorage.setItem(MODEL_DOWNLOADED_KEY, '1'); } catch {} }

    // helpers
    function appendMessage(role, text){
      const d = document.createElement('div');
      d.className = 'msg ' + (role === 'user' ? 'user' : 'assistant');
      d.textContent = text;
      chat.appendChild(d);
      chat.scrollTop = chat.scrollHeight;
      return d;
    }

    function clampString(s, maxChars){
      if(!s) return '';
      if(s.length <= maxChars) return s;
      return s.slice(0, maxChars - 3) + '...';
    }

    // overlay controls (first-time only)
    function showOverlay(title='Preparing model…', sub='Optimizing for low-memory', progress=0){
      overlayTitle.textContent = title;
      overlaySub.textContent = sub;
      overlayBar.style.width = `${Math.max(0, Math.min(1, progress)) * 100}%`;
      overlay.style.display = 'flex';
      overlay.setAttribute('aria-hidden', 'false');
    }
    function hideOverlay(){ overlay.style.display = 'none'; overlay.setAttribute('aria-hidden', 'true'); overlayBar.style.width = '0%'; }

    // Engine create with progress callback — sets downloaded flag on real download
    async function createEngineWithProgress() {
      const alreadyDownloaded = modelDownloadedFlag();
      let downloadObserved = false;

      const engine = await webllm.CreateMLCEngine(MODEL_ID, {
        initProgressCallback: (report) => {
          const p = Math.max(0, Math.min(1, (report && report.progress) || 0));
          const text = (report && report.text) || '';

          if (!alreadyDownloaded) {
            if (p < 1) {
              downloadObserved = true;
              showOverlay(text || 'Downloading model…', 'This happens only once on this device', p);
            } else {
              if (downloadObserved) setModelDownloadedFlag();
              hideOverlay();
            }
          }
          // if already downloaded, suppress any overlay
        }
      });

      return engine;
    }

    // Compact traits encoding: short tags to minimize tokens (e.g., "t:concise,numbered,eng")
    function compactTraitsTag(){
      const traits = (userTraits || []).slice(0, MAX_TRAITS).map(t => t.replace(/\s+/g,' ').trim().toLowerCase().replace(/[^a-z0-9 ]/g,'').split(' ')[0]); // pick short word
      if (!traits.length) return '';
      // join with commas
      return `t:${traits.slice(0, MAX_TRAITS).join(',')}`;
    }

    // build a compact system prompt that includes probabilistic reasoning + JSON-CoT policy
    function buildSystemPrompt(){
      // traits tag
      const tag = compactTraitsTag();
      // Probabilistic guidance (tiny)
      const prob = "Outputs are probabilistic; include Certainty:[High|Medium|Low].";
      // CoT JSON instruction (very compact)
      let cotInstr = "";
      const stepsLimit = (cotEnabled ? (lowPower ? 1 : 5) : 0);
      if (cotEnabled) {
        cotInstr = `Respond ONLY with a single JSON object: {"reasoning":[...short steps], "answer":"...", "certainty":"High|Medium|Low"}. Limit reasoning to ${stepsLimit} short items. No extra text.`;
      } else {
        // No CoT: still require a JSON answer with empty reasoning array
        cotInstr = `Respond ONLY with a single JSON object: {"reasoning":[], "answer":"...", "certainty":"High|Medium|Low"}. No extra text.`;
      }

      const base = lowPower ? "Be concise." : "Be concise.";
      const parts = [base, tag, prob, cotInstr].filter(Boolean);
      const system = parts.join(' ');
      return clampString(system, SYSTEM_PROMPT_CHAR_CAP);
    }

    function buildMessages(userText){
      const system = buildSystemPrompt();
      const historyTurns = lowPower ? HISTORY_TURNS_LOW : HISTORY_TURNS_NORMAL;
      const turnsToKeep = historyTurns * 2;
      const recent = history.slice(-turnsToKeep).map(m => ({ role: m.role === 'assistant' ? 'assistant' : 'user', content: m.content }));
      return [{ role: 'system', content: system }, ...recent, { role: 'user', content: userText }];
    }

    // Extract JSON object from model reply text, fallback to legacy extraction
    function extractJSONFromText(text) {
      if (!text || !text.trim()) return null;
      const first = text.indexOf('{');
      const last = text.lastIndexOf('}');
      if (first === -1 || last === -1 || last <= first) return null;
      const maybe = text.slice(first, last + 1);
      try {
        const parsed = JSON.parse(maybe);
        // Basic validation
        if (parsed && (Array.isArray(parsed.reasoning) || typeof parsed.answer === 'string')) return parsed;
      } catch (e) {
        // try to fix common issues: single quotes -> double quotes
        try {
          const fixed = maybe.replace(/(['"])?([a-zA-Z0-9_]+)(['"])?:/g, '"$2":').replace(/'/g, '"');
          const parsed2 = JSON.parse(fixed);
          if (parsed2 && (Array.isArray(parsed2.reasoning) || typeof parsed2.answer === 'string')) return parsed2;
        } catch (e2) {
          return null;
        }
      }
      return null;
    }

    // fallback extraction when JSON not returned
    function extractReasoningAndAnswerFallback(fullText) {
      // look for "Answer:" token (case-insensitive)
      const answerMatch = fullText.match(/Answer\s*:\s*([\s\S]*)$/i);
      if (answerMatch) {
        const answer = answerMatch[1].trim();
        const reasoningPart = fullText.slice(0, answerMatch.index).trim();
        const steps = reasoningPart ? reasoningPart.split(/\r?\n/).map(s => s.trim()).filter(Boolean) : [];
        return { steps, answer, certainty: null };
      }
      // try to extract certainty
      const certMatch = fullText.match(/(.*)\nCertainty\s*:\s*(High|Medium|Low)/i);
      if (certMatch) {
        return { steps: [], answer: certMatch[1].trim(), certainty: certMatch[2] };
      }
      return { steps: [], answer: fullText.trim(), certainty: null };
    }

    // Render assistant reply: if JSON present, parse and render. Show reasoning inline if user toggled it on.
    function renderAssistantReplyFromText(fullReply) {
      const json = extractJSONFromText(fullReply);
      if (json) {
        const answerText = json.answer || '';
        const certainty = json.certainty || '';
        const steps = Array.isArray(json.reasoning) ? json.reasoning : [];

        // assistant answer bubble
        const assistantDiv = document.createElement('div');
        assistantDiv.className = 'msg assistant';
        assistantDiv.textContent = answerText + (certainty ? `\n\nCertainty: ${certainty}` : '');
        chat.appendChild(assistantDiv);

        if (steps.length > 0) {
          const wrapper = document.createElement('div');
          wrapper.style.display = 'flex';
          wrapper.style.flexDirection = 'column';
          wrapper.style.alignItems = 'flex-start';
          wrapper.style.maxWidth = '78%';

          const toggle = document.createElement('button');
          toggle.className = 'btn';
          toggle.textContent = showReasoningInline ? 'Hide reasoning' : 'Show reasoning';
          toggle.style.marginTop = '6px';
          toggle.style.padding = '6px 8px';
          toggle.style.fontSize = '13px';

          const reasoningBox = document.createElement('div');
          reasoningBox.className = 'reasoning';
          reasoningBox.style.display = showReasoningInline ? 'block' : 'none';

          steps.forEach((s, i) => {
            const stepEl = document.createElement('div');
            stepEl.className = 'step';
            stepEl.textContent = `${i+1}. ${s}`;
            reasoningBox.appendChild(stepEl);
          });

          toggle.addEventListener('click', () => {
            const visible = reasoningBox.style.display !== 'none';
            reasoningBox.style.display = visible ? 'none' : 'block';
            toggle.textContent = visible ? 'Show reasoning' : 'Hide reasoning';
          });

          wrapper.appendChild(toggle);
          wrapper.appendChild(reasoningBox);
          chat.appendChild(wrapper);
        }

        chat.scrollTop = chat.scrollHeight;
        return;
      }

      // fallback: parse heuristically
      const fallback = extractReasoningAndAnswerFallback(fullReply);
      const assistantDiv = document.createElement('div');
      assistantDiv.className = 'msg assistant';
      assistantDiv.textContent = fallback.answer || fullReply || '…';
      chat.appendChild(assistantDiv);

      if (fallback.steps && fallback.steps.length) {
        const wrapper = document.createElement('div');
        wrapper.style.display = 'flex';
        wrapper.style.flexDirection = 'column';
        wrapper.style.alignItems = 'flex-start';
        wrapper.style.maxWidth = '78%';

        const toggle = document.createElement('button');
        toggle.className = 'btn';
        toggle.textContent = showReasoningInline ? 'Hide reasoning' : 'Show reasoning';
        toggle.style.marginTop = '6px';
        toggle.style.padding = '6px 8px';
        toggle.style.fontSize = '13px';

        const reasoningBox = document.createElement('div');
        reasoningBox.className = 'reasoning';
        reasoningBox.style.display = showReasoningInline ? 'block' : 'none';

        fallback.steps.forEach((s, i) => {
          const stepEl = document.createElement('div');
          stepEl.className = 'step';
          stepEl.textContent = `${i+1}. ${s}`;
          reasoningBox.appendChild(stepEl);
        });

        toggle.addEventListener('click', () => {
          const visible = reasoningBox.style.display !== 'none';
          reasoningBox.style.display = visible ? 'none' : 'block';
          toggle.textContent = visible ? 'Show reasoning' : 'Hide reasoning';
        });

        wrapper.appendChild(toggle);
        wrapper.appendChild(reasoningBox);
        chat.appendChild(wrapper);
      }

      chat.scrollTop = chat.scrollHeight;
    }

    // Core queue processing
    async function processQueue(){
      if (processing) return;
      processing = true;
      while (requestQueue.length) {
        const req = requestQueue.shift();
        await handleSingleRequest(req.userText);
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      processing = false;
    }

    // Handle single request implementing Method 4 and JSON-CoT constraints
    async function handleSingleRequest(userText) {
      const replyCharCap = lowPower ? REPLY_CHAR_CAP_LOW : REPLY_CHAR_CAP_NORMAL;
      const messages = buildMessages(userText);

      // Decide whether to show placeholder: remove/avoid "thinking" when lowPower is ON
      let placeholder = null;
      if (!lowPower) {
        placeholder = appendMessage('assistant', '…');
      }

      const alreadyDownloaded = modelDownloadedFlag();
      if (!alreadyDownloaded) {
        showOverlay('Preparing engine…', 'First-time model download may take longer', 0);
        await new Promise(requestAnimationFrame);
      } else {
        await new Promise(requestAnimationFrame);
      }

      sendBtn.disabled = true;

      try {
        engine = await createEngineWithProgress();

        const chunks = await engine.chat.completions.create({ messages, stream: true });

        let fullReply = '';
        for await (const chunk of chunks) {
          const delta = chunk?.choices?.[0]?.delta?.content || '';
          if (delta) {
            fullReply += delta;
            // update placeholder only when not lowPower
            if (placeholder) placeholder.textContent = fullReply;
            if (fullReply.length > replyCharCap) {
              fullReply = fullReply.slice(0, replyCharCap) + '\n\n[truncated to fit device limits]';
              if (placeholder) placeholder.textContent = fullReply;
              break;
            }
            chat.scrollTop = chat.scrollHeight;
          }
        }

        try { await engine.unload(); } catch(e) {}
        engine = null;

        // remove placeholder if present
        if (placeholder) placeholder.remove();

        // Render parsed JSON-like reply; if JSON isn't present, fallback rendering is used
        renderAssistantReplyFromText(fullReply);

        // persist history externally
        history.push({ role: 'user', content: userText }, { role: 'assistant', content: fullReply });
        const maxEntries = (lowPower ? HISTORY_TURNS_LOW : HISTORY_TURNS_NORMAL) * 2;
        if (maxEntries > 0 && history.length > maxEntries) history = history.slice(-maxEntries);
        if (maxEntries === 0) history = [];

        hideOverlay();
      } catch (err) {
        console.error('Inference error', err);
        if (placeholder) placeholder.remove();
        appendMessage('assistant', 'I had a memory spike or connection error. Try again in a moment.');
        try { if (engine) await engine.unload(); } catch(e){}
        engine = null;
        hideOverlay();
      } finally {
        sendBtn.disabled = false;
      }
    }

    // queue request (adds to single-run queue)
    function queueRequest(userText){
      if (!userText || !userText.trim()) return;
      appendMessage('user', userText);
      requestQueue.push({ userText });
      processQueue();
    }

    // UI wiring
    document.getElementById('send').addEventListener('click', () => {
      const txt = userInput.value.trim();
      if (!txt) return;
      userInput.value = '';
      queueRequest(txt);
    });
    userInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') { e.preventDefault(); document.getElementById('send').click(); } });

    // Reset
    resetBtn.addEventListener('click', async () => {
      history = [];
      chat.innerHTML = '<div class="msg assistant">Memory purged. Ready.</div>';
      requestQueue.length = 0;
      try { if (engine) await engine.unload(); } catch(e) {}
      engine = null;
      // do not clear modelDownloaded flag so overlay won't reappear
    });

    // Low-power toggle wiring
    lowPower = loadLowPower();
    lowPowerToggle.checked = lowPower;
    lowPowerToggle.addEventListener('change', (e) => {
      lowPower = !!e.target.checked;
      saveLowPower(lowPower);
      // if lowPower enabled, disable CoT to preserve memory (and sync toggle)
      if (lowPower && cotEnabled) {
        cotEnabled = false;
        cotToggle.checked = false;
        saveCoT(false);
        appendMessage('assistant', 'Low Power enabled — reasoning limited to preserve memory.');
      } else {
        appendMessage('assistant', lowPower ? 'Low Power enabled.' : 'Low Power disabled.');
      }
    });

    // CoT toggle wiring
    cotEnabled = loadCoT();
    cotToggle.checked = cotEnabled;
    if (lowPower && cotEnabled) { cotEnabled = false; cotToggle.checked = false; saveCoT(false); }
    cotToggle.addEventListener('change', (e) => {
      const requested = !!e.target.checked;
      if (lowPower && requested) {
        cotToggle.checked = false;
        cotEnabled = false;
        saveCoT(false);
        appendMessage('assistant', 'Cannot enable detailed reasoning while Low Power is ON.');
        return;
      }
      cotEnabled = requested;
      saveCoT(cotEnabled);
      appendMessage('assistant', cotEnabled ? 'Reasoning enabled (JSON output).' : 'Reasoning disabled.');
    });

    // Show reasoning inline toggle
    showReasoningInline = loadShowReasoning();
    showReasoningToggle.checked = showReasoningInline;
    showReasoningToggle.addEventListener('change', (e) => {
      showReasoningInline = !!e.target.checked;
      saveShowReasoning(showReasoningInline);
      appendMessage('assistant', showReasoningInline ? 'Reasoning will be shown inline.' : 'Reasoning will be hidden by default.');
    });

    // Traits editor wiring
    function openTraits(){ renderTraitsModal(); traitsOverlay.style.display = 'flex'; traitsOverlay.setAttribute('aria-hidden','false'); }
    function closeTraits(){ traitsOverlay.style.display = 'none'; traitsOverlay.setAttribute('aria-hidden','true'); }

    function renderTraitsModal(){
      traitsEditor.innerHTML = '';
      traitsChips.innerHTML = '';
      userTraits.forEach((t, idx) => {
        const chip = document.createElement('div'); chip.className = 'chip'; chip.textContent = t; traitsChips.appendChild(chip);
        const row = document.createElement('div');
        row.style.display = 'flex'; row.style.gap = '8px'; row.style.alignItems = 'center';
        const input = document.createElement('input'); input.value = t; input.placeholder = `Trait ${idx+1}`;
        input.addEventListener('input', () => userTraits[idx] = input.value);
        const rm = document.createElement('button'); rm.className = 'btn'; rm.textContent = 'Remove';
        rm.addEventListener('click', () => { userTraits.splice(idx,1); renderTraitsModal(); });
        row.appendChild(input); row.appendChild(rm);
        traitsEditor.appendChild(row);
      });
      traitsCount.textContent = `${userTraits.length}/${MAX_TRAITS}`;
    }

    addTraitBtn.addEventListener('click', () => {
      if (userTraits.length >= MAX_TRAITS) return;
      userTraits.push('');
      renderTraitsModal();
    });
    saveTraitsBtn.addEventListener('click', () => {
      userTraits = userTraits.map(s => (s || '').trim()).filter(Boolean).slice(0, MAX_TRAITS);
      saveTraits(userTraits);
      closeTraits();
      appendMessage('assistant', 'Traits saved.');
    });
    cancelTraitsBtn.addEventListener('click', () => closeTraits());
    traitsBtn.addEventListener('click', () => openTraits());

    // initial load
    userTraits = loadTraits();
    if (!userTraits || !userTraits.length) {
      userTraits = ['Concise','Numbered steps','English'];
      saveTraits(userTraits);
    }
    lowPower = loadLowPower();
    cotEnabled = loadCoT();
    showReasoningInline = loadShowReasoning();
    // ensure CoT disabled while in Low Power
    if (lowPower && cotEnabled) { cotEnabled = false; cotToggle.checked = false; saveCoT(false); }

    // sync toggles visually after load
    lowPowerToggle.checked = lowPower;
    cotToggle.checked = cotEnabled;
    showReasoningToggle.checked = showReasoningInline;

    // focus input
    userInput.focus();
  </script>
</body>
</html>
